<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zone Control</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
        }
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 100vw;
            padding: 10px;
            box-sizing: border-box;
        }
        #info {
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            margin-bottom: 10px;
            width: 100%;
            max-width: 500px;
            box-sizing: border-box;
        }
        #difficultySelector {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        #difficultySelector label {
            color: white;
            font-size: 14px;
            font-weight: bold;
        }
        .difficultyButton {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid #4A90E2;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .difficultyButton:hover:not(:disabled) {
            background: rgba(74, 144, 226, 0.3);
            border-color: #357ABD;
        }
        .difficultyButton.selected {
            background: #4A90E2;
            border-color: #357ABD;
        }
        .difficultyButton:disabled {
            color: #888;
            cursor: not-allowed;
            opacity: 0.5;
            font-style: italic;
        }
        #newGameButton {
            background: #4A90E2;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 10px;
            transition: background 0.3s;
        }
        #newGameButton:hover {
            background: #357ABD;
        }
        #newGameButton:active {
            background: #2E5C8A;
        }
        canvas {
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            max-width: 100%;
            max-height: calc(100vh - 200px);
            width: auto;
            height: auto;
        }
        @media (max-width: 600px) {
            #info {
                font-size: 12px;
                padding: 8px;
            }
            body {
                padding: 5px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="difficultySelector">
            <label>Difficulty:</label>
            <button class="difficultyButton" data-level="0">Baby</button>
            <button class="difficultyButton selected" data-level="1">Normal</button>
            <button class="difficultyButton" data-level="2">Hard</button>
            <button class="difficultyButton" data-level="3" id="godButton" disabled>God</button>
        </div>
        <button id="newGameButton">New Game</button>
        <div id="info">
            <div>Player Units: <span id="playerUnits">0</span></div>
            <div>Enemy Units: <span id="enemyUnits">0</span></div>
            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255, 255, 255, 0.3);">
                <div>Blue Tiles: <span id="blueTiles">0</span></div>
                <div>Red Tiles: <span id="redTiles">0</span></div>
            </div>
            <div style="margin-top: 10px; font-size: 12px;">
                Click and drag from your cells to send units!<br>
                The more zones you control, the faster you gain units.
            </div>
        </div>
    </div>

    <script>
        // Game configuration
        const GRID_SIZE = 3; // Hexagon grid radius (number of hexagons from center)
        const HEX_SIZE = 50; // Hexagon size (radius from center to corner)
        const UNIT_RADIUS = 4;
        const GAME_SPEED = 1.75; // Game speed multiplier (1.0 = normal speed)
        const UNIT_SPEED = 69 * GAME_SPEED; // Pixels per second
        const UNIT_WANDER_SPEED = 21 * GAME_SPEED; // Pixels per second
        const UNIT_WANDER_RADIUS = 30; // Reduced for hexagons
        const BASE_SPAWN_RATE = 4.5 / GAME_SPEED; // Seconds between spawns (at 60fps, 270 frames = 4.5 seconds)
        const SPAWN_RATE_PER_CELL = 0.15 / GAME_SPEED; // Seconds faster spawn per owned cell (at 60fps, 9 frames = 0.15 seconds)
        const CAPTURE_RATE = 9 * GAME_SPEED; // How fast cells are captured/neutralized per second (higher = faster)
        const SHIELD_HEALTH = CAPTURE_RATE / 8; // How fast shields are broken per second (higher = faster shield breaking)
        
        // Hexagon grid utilities
        // Using axial coordinates (q, r) for hexagons
        // Pointy-top hexagon layout
        const HEX_WIDTH = Math.sqrt(3) * HEX_SIZE;
        const HEX_HEIGHT = 2 * HEX_SIZE;
        
        // Hexagon direction vectors (6 neighbors)
        const HEX_DIRECTIONS = [
            { q: 1, r: 0 },   // East
            { q: 1, r: -1 },  // Northeast
            { q: 0, r: -1 },  // Northwest
            { q: -1, r: 0 },  // West
            { q: -1, r: 1 },  // Southwest
            { q: 0, r: 1 }    // Southeast
        ];
        
        // Convert hex coordinates (q, r) to pixel coordinates
        function hexToPixel(q, r) {
            const x = HEX_WIDTH * (q + r / 2);
            const y = HEX_HEIGHT * 0.75 * r;
            return { x, y };
        }
        
        // Convert pixel coordinates to hex coordinates (q, r)
        function pixelToHex(x, y) {
            // For pointy-top hexagons
            const q = (Math.sqrt(3)/3 * x - 1/3 * y) / HEX_SIZE;
            const r = (2/3 * y) / HEX_SIZE;
            return hexRound(q, r);
        }
        
        // Round fractional hex coordinates to nearest hex
        function hexRound(q, r) {
            let s = -q - r;
            let rq = Math.round(q);
            let rr = Math.round(r);
            let rs = Math.round(s);
            
            const qDiff = Math.abs(rq - q);
            const rDiff = Math.abs(rr - r);
            const sDiff = Math.abs(rs - s);
            
            if (qDiff > rDiff && qDiff > sDiff) {
                rq = -rr - rs;
            } else if (rDiff > sDiff) {
                rr = -rq - rs;
            }
            
            return { q: rq, r: rr };
        }
        
        // Get neighbors of a hex
        function getHexNeighbors(q, r) {
            return HEX_DIRECTIONS.map(dir => ({
                q: q + dir.q,
                r: r + dir.r
            }));
        }
        
        // Generate all hexes in a hexagonal grid of given radius
        function generateHexGrid(radius) {
            const hexes = [];
            for (let q = -radius; q <= radius; q++) {
                const r1 = Math.max(-radius, -q - radius);
                const r2 = Math.min(radius, -q + radius);
                for (let r = r1; r <= r2; r++) {
                    hexes.push({ q, r });
                }
            }
            return hexes;
        }
        
        // Check if hex coordinates are within grid bounds
        function isHexInBounds(q, r, radius) {
            return Math.abs(q) <= radius && Math.abs(r) <= radius && Math.abs(-q - r) <= radius;
        }
        
        // Draw a hexagon at given position
        function drawHexagon(graphics, x, y, size, fillColor, fillAlpha, lineColor, lineWidth) {
            graphics.clear();
            if (fillColor !== undefined) {
                graphics.beginFill(fillColor, fillAlpha !== undefined ? fillAlpha : 1);
            }
            if (lineColor !== undefined) {
                graphics.lineStyle(lineWidth !== undefined ? lineWidth : 1, lineColor, 1);
            }
            
            // Draw hexagon (pointy-top)
            const points = [];
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 3 * i - Math.PI / 6; // Start at top
                points.push(x + size * Math.cos(angle), y + size * Math.sin(angle));
            }
            graphics.drawPolygon(points);
            
            if (fillColor !== undefined) {
                graphics.endFill();
            }
        }
        
        // Check if point is inside hexagon
        function pointInHexagon(px, py, hx, hy, size) {
            const dx = px - hx;
            const dy = py - hy;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // For pointy-top hexagon, the circumscribed circle radius is size
            // Use the full size for easier clicking
            return distance <= size;
        }

        // Difficulty level (0 = Baby, 1 = Normal, 2 = Hard, 3 = God)
        let DIFFICULTY_LEVEL = 1; // Default to Normal

        // Get difficulty multiplier for enemy units
        // Difficulty 0: 0.9 (10% slower), 1: 1.0 (normal), 2: 1.1 (10% faster), 3: 1.2 (20% faster)
        function getEnemyDifficultyMultiplier() {
            return 0.9 + (DIFFICULTY_LEVEL * 0.1);
        }

        // Colors
        const COLORS = {
            NEUTRAL: 0xFFFFFF,
            PLAYER: 0x4A90E2,
            ENEMY: 0xE74C3C,
            GRID: 0x2C3E50,
            UNIT_PLAYER: 0x2E5C8A,
            UNIT_ENEMY: 0xA93226,
            SHIELD: 0xFFD700 // Gold color for shield
        };

        // Calculate canvas size for hexagon grid
        const hexGrid = generateHexGrid(GRID_SIZE);
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        hexGrid.forEach(hex => {
            const pos = hexToPixel(hex.q, hex.r);
            minX = Math.min(minX, pos.x);
            maxX = Math.max(maxX, pos.x);
            minY = Math.min(minY, pos.y);
            maxY = Math.max(maxY, pos.y);
        });
        const CANVAS_WIDTH = maxX - minX + HEX_SIZE * 2;
        const CANVAS_HEIGHT = maxY - minY + HEX_SIZE * 2;
        const CANVAS_OFFSET_X = -minX + HEX_SIZE;
        const CANVAS_OFFSET_Y = -minY + HEX_SIZE;
        
        // Initialize PixiJS application
        const app = new PIXI.Application({
            width: CANVAS_WIDTH,
            height: CANVAS_HEIGHT,
            backgroundColor: 0x16213e,
            antialias: true,
            resolution: window.devicePixelRatio || 1,
            autoDensity: true
        });
        document.getElementById('gameContainer').appendChild(app.view);
        
        // Base values for info panel (scoreboard)
        const INFO_BASE_FONT_SIZE = 14;
        const INFO_BASE_PADDING = 10;
        const INFO_BASE_MAX_WIDTH = 500;
        const INFO_BASE_BORDER_RADIUS = 5;
        
        // Function to scale canvas to fit viewport on mobile
        function scaleCanvas() {
            const canvas = app.view;
            const container = document.getElementById('gameContainer');
            const info = document.getElementById('info');
            
            const gameWidth = CANVAS_WIDTH;
            const gameHeight = CANVAS_HEIGHT;
            
            // Get available space (accounting for info panel and padding)
            const infoHeight = info.offsetHeight;
            const padding = 20;
            const availableWidth = window.innerWidth - padding;
            const availableHeight = window.innerHeight - infoHeight - padding - 20;
            
            // Calculate scale to fit both width and height
            const scaleX = availableWidth / gameWidth;
            const scaleY = availableHeight / gameHeight;
            const scale = Math.min(scaleX, scaleY, 1); // Don't scale up on desktop
            
            // Apply scaling to canvas
            if (scale < 1) {
                canvas.style.width = (gameWidth * scale) + 'px';
                canvas.style.height = (gameHeight * scale) + 'px';
            } else {
                // On desktop, use original size
                canvas.style.width = gameWidth + 'px';
                canvas.style.height = gameHeight + 'px';
            }
            
            // Apply same scaling to info panel (scoreboard)
            const BASE_SPACING = 10;
            const BASE_INSTRUCTION_FONT = 12;
            
            if (scale < 1) {
                info.style.fontSize = (INFO_BASE_FONT_SIZE * scale) + 'px';
                info.style.padding = (INFO_BASE_PADDING * scale) + 'px';
                info.style.maxWidth = (INFO_BASE_MAX_WIDTH * scale) + 'px';
                info.style.borderRadius = (INFO_BASE_BORDER_RADIUS * scale) + 'px';
                info.style.marginBottom = (BASE_SPACING * scale) + 'px';
                
                // Scale spacing in child divs (margin-top and padding-top)
                const childDivs = info.querySelectorAll('div > div');
                childDivs.forEach(div => {
                    if (div.style.marginTop && div.style.marginTop.includes('px')) {
                        div.style.marginTop = (BASE_SPACING * scale) + 'px';
                    }
                    if (div.style.paddingTop && div.style.paddingTop.includes('px')) {
                        div.style.paddingTop = (BASE_SPACING * scale) + 'px';
                    }
                });
                
                // Scale the instruction text font size
                const instructionDiv = info.querySelector('div:last-child');
                if (instructionDiv && instructionDiv.style.fontSize) {
                    instructionDiv.style.fontSize = (BASE_INSTRUCTION_FONT * scale) + 'px';
                }
            } else {
                // Reset to original values on desktop
                info.style.fontSize = INFO_BASE_FONT_SIZE + 'px';
                info.style.padding = INFO_BASE_PADDING + 'px';
                info.style.maxWidth = INFO_BASE_MAX_WIDTH + 'px';
                info.style.borderRadius = INFO_BASE_BORDER_RADIUS + 'px';
                info.style.marginBottom = BASE_SPACING + 'px';
                
                // Reset spacing in child divs
                const childDivs = info.querySelectorAll('div > div');
                childDivs.forEach(div => {
                    if (div.style.marginTop && div.style.marginTop.includes('px')) {
                        div.style.marginTop = BASE_SPACING + 'px';
                    }
                    if (div.style.paddingTop && div.style.paddingTop.includes('px')) {
                        div.style.paddingTop = BASE_SPACING + 'px';
                    }
                });
                
                const instructionDiv = info.querySelector('div:last-child');
                if (instructionDiv && instructionDiv.style.fontSize) {
                    instructionDiv.style.fontSize = BASE_INSTRUCTION_FONT + 'px';
                }
            }
        }
        
        // Scale on load and resize
        scaleCanvas();
        window.addEventListener('resize', scaleCanvas);
        window.addEventListener('orientationchange', () => {
            setTimeout(scaleCanvas, 100); // Small delay for orientation change
        });

        // Game state
        const gameState = {
            cells: [],
            units: [],
            selectedCell: null,
            dragLine: null,
            isDragging: false,
            playerSpawnTimer: 0,
            enemySpawnTimer: 0,
            aiMoveTimer: 0,
            aiNextMoveDelay: 0,
            playerTotalUnitsProduced: 0,
            enemyTotalUnitsProduced: 0,
            gameOver: false,
            isPlaying: false
        };

        // Cell class
        class Cell {
            constructor(q, r) {
                this.q = q; // Hex column
                this.r = r; // Hex row
                this.owner = 'neutral'; // 'neutral', 'player', 'enemy'
                this.units = [];
                this.captureProgress = 0; // 0 to 100, progress towards capturing
                this.capturingOwner = null; // Who is trying to capture this cell
                this.hasShield = false; // Whether this cell has a shield
                this.shieldProgress = 0; // 0 to 100, progress towards breaking shield
                this.shieldConsumeTimer = 0; // Timer for consuming units (1 unit per second)
                
                // Get pixel position for this hex
                const pixelPos = hexToPixel(q, r);
                const centerX = pixelPos.x + CANVAS_OFFSET_X;
                const centerY = pixelPos.y + CANVAS_OFFSET_Y;
                
                // Create cell graphics
                this.container = new PIXI.Container();
                this.container.x = centerX;
                this.container.y = centerY;
                
                // Background
                this.bg = new PIXI.Graphics();
                this.updateColor();
                this.container.addChild(this.bg);
                
                // Border
                this.border = new PIXI.Graphics();
                this.updateBorder();
                this.container.addChild(this.border);
                
                // Capture progress bar
                this.progressBar = new PIXI.Graphics();
                this.container.addChild(this.progressBar);
                
                // Unit count text
                this.unitText = new PIXI.Text('', {
                    fontFamily: 'Arial',
                    fontSize: 20,
                    fill: 0x000000,
                    fontWeight: 'bold'
                });
                this.unitText.anchor.set(0.5);
                this.unitText.x = 0;
                this.unitText.y = 0;
                this.container.addChild(this.unitText);
                
                // Make interactive
                this.container.interactive = true;
                this.container.buttonMode = true;
                
                app.stage.addChild(this.container);
            }
            
            updateBorder() {
                this.border.clear();
                const borderColor = this.hasShield ? COLORS.SHIELD : COLORS.GRID;
                drawHexagon(this.border, 0, 0, HEX_SIZE, undefined, undefined, borderColor, 2);
            }
            
            updateColor() {
                this.bg.clear();
                let color = COLORS.NEUTRAL;
                if (this.owner === 'player') color = COLORS.PLAYER;
                else if (this.owner === 'enemy') color = COLORS.ENEMY;
                
                // Draw hexagon background
                drawHexagon(this.bg, 0, 0, HEX_SIZE, color, 0.6);
                
                // Update border
                if (this.border) {
                    this.updateBorder();
                }
            }
            
            updateCaptureProgress(dt) {
                const playerUnits = this.units.filter(u => u.owner === 'player').length;
                const enemyUnits = this.units.filter(u => u.owner === 'enemy').length;
                
                // Determine who has more units
                let dominantOwner = null;
                let unitAdvantage = 0;
                
                if (playerUnits > enemyUnits) {
                    dominantOwner = 'player';
                    unitAdvantage = playerUnits - enemyUnits;
                } else if (enemyUnits > playerUnits) {
                    dominantOwner = 'enemy';
                    unitAdvantage = enemyUnits - playerUnits;
                }
                
                // Handle shield logic first
                if (this.hasShield) {
                    // Determine if shield is being attacked
                    // Shield protects the cell's owner, so it's attacked when opponent has more units
                    const isShieldAttacked = dominantOwner && dominantOwner !== this.owner && unitAdvantage > 0;
                    
                    if (isShieldAttacked) {
                        // Shield is being attacked - break it
                        this.shieldProgress += unitAdvantage * SHIELD_HEALTH * dt;
                        
                        // Consume 1 unit per second from attacking units
                        // Track accumulated time for unit consumption
                        this.shieldConsumeTimer += dt;
                        if (this.shieldConsumeTimer >= 1.0) {
                            this.shieldConsumeTimer = 0;
                            const attackingUnits = this.units.filter(u => u.owner === dominantOwner);
                            if (attackingUnits.length > 0) {
                                const unit = attackingUnits[0];
                                unit.destroy();
                                gameState.units = gameState.units.filter(u => u !== unit);
                                this.units = this.units.filter(u => u !== unit);
                            }
                        }
                        
                        if (this.shieldProgress >= 100) {
                            // Shield broken! Keep the owner, let normal capture logic handle owner -> neutral -> new owner
                            this.hasShield = false;
                            this.shieldProgress = 0;
                            this.shieldConsumeTimer = 0; // Reset timer
                            // Don't change owner - let it show the original owner's color first
                            // Then normal capture logic will neutralize it, then capture it
                            this.captureProgress = 100; // Set to 100 so it shows as fully owned
                            this.updateColor();
                            // Reorder cells so shield cells (gold borders) are drawn on top
                            reorderCells();
                        }
                    } else {
                        // Shield not being attacked - decay shield progress and reset timer
                        if (this.shieldProgress > 0) {
                            this.shieldProgress -= 12 * GAME_SPEED * dt;
                            if (this.shieldProgress < 0) this.shieldProgress = 0;
                        }
                        this.shieldConsumeTimer = 0; // Reset timer when not being attacked
                    }
                    
                    // Draw shield progress bar
                    this.progressBar.clear();
                    if (this.shieldProgress > 0 && this.shieldProgress < 100) {
                        const barWidth = (HEX_SIZE * 1.5) * (this.shieldProgress / 100);
                        // Background
                        this.progressBar.beginFill(0x000000, 0.3);
                        this.progressBar.drawRect(-HEX_SIZE * 0.75, HEX_SIZE * 0.6, HEX_SIZE * 1.5, 8);
                        this.progressBar.endFill();
                        // Shield progress (gold)
                        this.progressBar.beginFill(COLORS.SHIELD, 0.8);
                        this.progressBar.drawRect(-HEX_SIZE * 0.75, HEX_SIZE * 0.6, barWidth, 8);
                        this.progressBar.endFill();
                    }
                    return; // Shield logic handled, exit early
                }
                
                // Normal capture logic (when no shield)
                // If cell is already owned by dominant owner, maintain ownership
                if (dominantOwner === this.owner) {
                    this.captureProgress = 100;
                    this.capturingOwner = null;
                }
                // If cell is owned but has no units, keep the ownership (don't turn neutral)
                else if (this.owner !== 'neutral' && playerUnits === 0 && enemyUnits === 0) {
                    // Keep current ownership when cell is empty
                    this.captureProgress = 100;
                    this.capturingOwner = null;
                }
                // If cell is neutral and empty, stay neutral
                else if (this.owner === 'neutral' && playerUnits === 0 && enemyUnits === 0) {
                    this.captureProgress = 0;
                    this.capturingOwner = null;
                }
                // If someone else is dominant, start/continue capture
                else if (dominantOwner && dominantOwner !== this.owner) {
                    // If this is a new capturer or continuing neutralization, set capturing owner
                    if (this.capturingOwner !== dominantOwner) {
                        this.capturingOwner = dominantOwner;
                    }
                    
                    // If cell is owned by opponent, first neutralize it
                    if (this.owner !== 'neutral') {
                        // Decrease progress (neutralizing the cell)
                        const captureRate = dominantOwner === 'enemy' ? CAPTURE_RATE * getEnemyDifficultyMultiplier() : CAPTURE_RATE;
                        this.captureProgress -= unitAdvantage * captureRate * dt;
                        
                        if (this.captureProgress <= 0) {
                            this.owner = 'neutral';
                            this.captureProgress = 0;
                            this.updateColor();
                        }
                    } else {
                        // Cell is neutral, now capture it
                        const captureRate = dominantOwner === 'enemy' ? CAPTURE_RATE * getEnemyDifficultyMultiplier() : CAPTURE_RATE;
                        this.captureProgress += unitAdvantage * captureRate * dt;
                        
                        if (this.captureProgress >= 100) {
                            this.captureProgress = 100;
                            this.owner = dominantOwner;
                            this.capturingOwner = null;
                            this.updateColor();
                        }
                    }
                }
                // Equal units or no dominant owner, but cell is owned - keep ownership
                else if (this.owner !== 'neutral') {
                    this.captureProgress = 100;
                    this.capturingOwner = null;
                }
                // Neutral cell with equal or no units
                else {
                // Slowly decay capture progress
                // Original was 0.2 per frame at 60fps = 12 per second
                if (this.captureProgress > 0) {
                    this.captureProgress -= 12 * GAME_SPEED * dt;
                    if (this.captureProgress < 0) this.captureProgress = 0;
                }
                    if (this.captureProgress === 0) {
                        this.capturingOwner = null;
                    }
                }
                
                // Draw progress bar
                this.progressBar.clear();
                
                // Show progress bar during neutralization (owned -> neutral)
                if (this.owner !== 'neutral' && this.capturingOwner && this.capturingOwner !== this.owner) {
                    const barWidth = (HEX_SIZE * 1.5) * (this.captureProgress / 100);
                    let barColor = this.owner === 'player' ? COLORS.PLAYER : COLORS.ENEMY;
                    
                    // Background
                    this.progressBar.beginFill(0x000000, 0.3);
                    this.progressBar.drawRect(-HEX_SIZE * 0.75, HEX_SIZE * 0.6, HEX_SIZE * 1.5, 8);
                    this.progressBar.endFill();
                    
                    // Progress (shows how much ownership remains)
                    this.progressBar.beginFill(barColor, 0.8);
                    this.progressBar.drawRect(-HEX_SIZE * 0.75, HEX_SIZE * 0.6, barWidth, 8);
                    this.progressBar.endFill();
                }
                // Show progress bar during capture (neutral -> owned)
                else if (this.captureProgress > 0 && this.captureProgress < 100 && this.owner === 'neutral' && this.capturingOwner) {
                    const barWidth = (HEX_SIZE * 1.5) * (this.captureProgress / 100);
                    let barColor = this.capturingOwner === 'player' ? COLORS.PLAYER : COLORS.ENEMY;
                    
                    // Background
                    this.progressBar.beginFill(0x000000, 0.3);
                    this.progressBar.drawRect(-HEX_SIZE * 0.75, HEX_SIZE * 0.6, HEX_SIZE * 1.5, 8);
                    this.progressBar.endFill();
                    
                    // Progress
                    this.progressBar.beginFill(barColor, 0.8);
                    this.progressBar.drawRect(-HEX_SIZE * 0.75, HEX_SIZE * 0.6, barWidth, 8);
                    this.progressBar.endFill();
                }
            }
            
            updateUnitCount() {
                const count = this.units.length;
                this.unitText.text = count > 0 ? count.toString() : '';
            }
            
            getCenterWorld() {
                return {
                    x: this.container.x,
                    y: this.container.y
                };
            }
        }

        // Unit class
        class Unit {
            constructor(owner, cell) {
                this.owner = owner; // 'player' or 'enemy'
                this.cell = cell;
                this.isMoving = false;
                this.targetCell = null;
                
                // Graphics
                this.graphics = new PIXI.Graphics();
                this.graphics.lineStyle(1, 0xFFFFFF, 1); // White outline
                this.graphics.beginFill(owner === 'player' ? COLORS.UNIT_PLAYER : COLORS.UNIT_ENEMY);
                this.graphics.drawCircle(0, 0, UNIT_RADIUS);
                this.graphics.endFill();
                
                // Position in cell
                const center = cell.getCenterWorld();
                this.x = center.x;
                this.y = center.y;
                
                // Wandering behavior - velocity-based steering
                this.velocityAngle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(this.velocityAngle) * UNIT_WANDER_SPEED;
                this.vy = Math.sin(this.velocityAngle) * UNIT_WANDER_SPEED;
                
                this.updatePosition();
                app.stage.addChild(this.graphics);
                
                // Add to cell
                cell.units.push(this);
            }
            
            updatePosition() {
                this.graphics.x = this.x;
                this.graphics.y = this.y;
            }
            
            wander(dt) {
                if (this.isMoving) return;
                
                const center = this.cell.getCenterWorld();
                
                // Calculate distance from center
                const distFromCenterX = this.x - center.x;
                const distFromCenterY = this.y - center.y;
                const distFromCenter = Math.sqrt(distFromCenterX * distFromCenterX + distFromCenterY * distFromCenterY);
                
                // Steering behavior: gradually change direction (random wander)
                // Original was 0.08 per frame at 60fps = 4.8 per second
                this.velocityAngle += (Math.random() - 0.5) * 4.8 * GAME_SPEED * dt;
                
                // Check if unit is near hexagon boundary
                const maxDist = HEX_SIZE - UNIT_RADIUS - 5;
                if (distFromCenter > maxDist) {
                    // Steer back towards center
                    const angleToCenter = Math.atan2(-distFromCenterY, -distFromCenterX);
                    this.velocityAngle = this.velocityAngle * 0.9 + angleToCenter * 0.1;
                }
                
                // Only gently steer back towards center if very far (much less aggressive)
                if (distFromCenter > UNIT_WANDER_RADIUS * 1.2) {
                    const angleToCenter = Math.atan2(-distFromCenterY, -distFromCenterX);
                    this.velocityAngle = this.velocityAngle * 0.95 + angleToCenter * 0.05;
                }
                
                // Update velocity based on angle
                this.vx = Math.cos(this.velocityAngle) * UNIT_WANDER_SPEED;
                this.vy = Math.sin(this.velocityAngle) * UNIT_WANDER_SPEED;
                
                // Move based on velocity (scaled by delta time)
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                
                // Clamp position to hexagon bounds (keep within hexagon)
                const newDistFromCenter = Math.sqrt((this.x - center.x) ** 2 + (this.y - center.y) ** 2);
                if (newDistFromCenter > maxDist) {
                    // Project back onto hexagon boundary
                    const angle = Math.atan2(this.y - center.y, this.x - center.x);
                    this.x = center.x + Math.cos(angle) * maxDist;
                    this.y = center.y + Math.sin(angle) * maxDist;
                }
                
                this.updatePosition();
            }
            
            moveTo(targetCell) {
                this.isMoving = true;
                this.targetCell = targetCell;
                
                // Remove from current cell
                const index = this.cell.units.indexOf(this);
                if (index > -1) {
                    this.cell.units.splice(index, 1);
                }
                this.cell = null;
            }
            
            update(deltaTime) {
                const dt = deltaTime / 1000; // Convert milliseconds to seconds
                
                if (this.isMoving && this.targetCell) {
                    const target = this.targetCell.getCenterWorld();
                    const dx = target.x - this.x;
                    const dy = target.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Apply difficulty multiplier to enemy move speed
                    const unitSpeed = this.owner === 'enemy' ? UNIT_SPEED * getEnemyDifficultyMultiplier() : UNIT_SPEED;
                    const moveDistance = unitSpeed * dt;
                    if (dist < moveDistance) {
                        // Arrived at destination
                        this.x = target.x;
                        this.y = target.y;
                        this.isMoving = false;
                        this.cell = this.targetCell;
                        this.targetCell.units.push(this);
                        this.targetCell = null;
                        
                        // Reset wander - initialize velocity-based steering
                        this.velocityAngle = Math.random() * Math.PI * 2;
                        this.vx = Math.cos(this.velocityAngle) * UNIT_WANDER_SPEED;
                        this.vy = Math.sin(this.velocityAngle) * UNIT_WANDER_SPEED;
                    } else {
                        // Move towards target
                        this.x += (dx / dist) * moveDistance;
                        this.y += (dy / dist) * moveDistance;
                    }
                    this.updatePosition();
                } else {
                    this.wander(dt);
                }
            }
            
            destroy() {
                app.stage.removeChild(this.graphics);
                this.graphics.destroy();
            }
        }

        // Initialize grid
        function initGrid() {
            gameState.cells = new Map(); // Use Map for hex coordinates
            const hexGrid = generateHexGrid(GRID_SIZE);
            hexGrid.forEach(hex => {
                const key = `${hex.q},${hex.r}`;
                gameState.cells.set(key, new Cell(hex.q, hex.r));
            });
        }
        
        // Get cell by hex coordinates
        function getCellByHex(q, r) {
            const key = `${q},${r}`;
            return gameState.cells.get(key) || null;
        }
        
        // Reorder cells so shield cells (gold borders) are drawn on top
        function reorderCells() {
            const cells = Array.from(gameState.cells.values());
            const shieldCells = [];
            const normalCells = [];
            
            // Collect all unit graphics and drag line to preserve their z-order
            const units = [];
            const dragLine = gameState.dragLine;
            
            // Collect all units from stage
            gameState.units.forEach(unit => {
                if (unit.graphics && app.stage.children.includes(unit.graphics)) {
                    units.push(unit.graphics);
                }
            });
            
            // Remove units and drag line temporarily
            units.forEach(graphics => {
                app.stage.removeChild(graphics);
            });
            if (dragLine && app.stage.children.includes(dragLine)) {
                app.stage.removeChild(dragLine);
            }
            
            // Separate cells by shield status
            cells.forEach(cell => {
                if (cell.hasShield) {
                    shieldCells.push(cell.container);
                } else {
                    normalCells.push(cell.container);
                }
            });
            
            // Remove all cells from stage
            cells.forEach(cell => {
                app.stage.removeChild(cell.container);
            });
            
            // Add normal cells first, then shield cells (so shield cells are on top)
            normalCells.forEach(container => {
                app.stage.addChild(container);
            });
            shieldCells.forEach(container => {
                app.stage.addChild(container);
            });
            
            // Re-add units and drag line on top
            units.forEach(graphics => {
                app.stage.addChild(graphics);
            });
            if (dragLine) {
                app.stage.addChild(dragLine);
            }
        }

        // Initialize units
        function initUnits() {
            // Find player spawn cell (bottom right - maximum q+r)
            let playerCell = null;
            let maxSum = -Infinity;
            for (const cell of gameState.cells.values()) {
                const sum = cell.q + cell.r;
                if (sum > maxSum) {
                    maxSum = sum;
                    playerCell = cell;
                }
            }
            
            if (playerCell) {
                for (let i = 0; i < 5; i++) {
                    const unit = new Unit('player', playerCell);
                    gameState.units.push(unit);
                    gameState.playerTotalUnitsProduced++;
                }
                playerCell.owner = 'player';
                playerCell.hasShield = true; // Home tile starts with shield
                playerCell.shieldProgress = 0;
                playerCell.updateColor();
            }
            
            // Find enemy spawn cell - farthest from player (opposite corner, top-left)
            // In hex grid, find the topmost cell (minimum r), then leftmost (minimum q)
            let enemyCell = null;
            let minR = Infinity;
            for (const cell of gameState.cells.values()) {
                if (cell.r < minR) {
                    minR = cell.r;
                    enemyCell = cell;
                } else if (cell.r === minR && cell.q < enemyCell.q) {
                    enemyCell = cell;
                }
            }
            
            if (enemyCell) {
                const enemyUnitCount = DIFFICULTY_LEVEL === 3 ? 10 : 5;
                for (let i = 0; i < enemyUnitCount; i++) {
                    const unit = new Unit('enemy', enemyCell);
                    gameState.units.push(unit);
                    gameState.enemyTotalUnitsProduced++;
                }
                enemyCell.owner = 'enemy';
                enemyCell.hasShield = true; // Home tile starts with shield
                enemyCell.shieldProgress = 0;
                enemyCell.updateColor();
            }
            
            // Reorder cells so shield cells (gold borders) are drawn on top
            reorderCells();
        }

        // Input handling
        function setupInput() {
            // Mouse events
            app.view.addEventListener('mousedown', onMouseDown);
            app.view.addEventListener('mousemove', onMouseMove);
            app.view.addEventListener('mouseup', onMouseUp);
            
            // Touch events
            app.view.addEventListener('touchstart', onTouchStart, { passive: false });
            app.view.addEventListener('touchmove', onTouchMove, { passive: false });
            app.view.addEventListener('touchend', onTouchEnd, { passive: false });
            app.view.addEventListener('touchcancel', onTouchEnd, { passive: false });
        }

        // Helper function to convert screen coordinates to game coordinates
        function screenToGameCoords(screenX, screenY) {
            const canvas = app.view;
            const rect = canvas.getBoundingClientRect();
            
            // Get the actual canvas dimensions (game space)
            const gameWidth = CANVAS_WIDTH;
            const gameHeight = CANVAS_HEIGHT;
            
            // Get the displayed canvas dimensions (CSS scaled)
            const displayWidth = rect.width;
            const displayHeight = rect.height;
            
            // Calculate scale factors
            const scaleX = gameWidth / displayWidth;
            const scaleY = gameHeight / displayHeight;
            
            // Convert screen coordinates to game coordinates
            const gameX = (screenX - rect.left) * scaleX;
            const gameY = (screenY - rect.top) * scaleY;
            
            return { x: gameX, y: gameY };
        }

        function getCellFromPosition(x, y) {
            // First, try to find the cell by checking all hexagons directly
            // This is more reliable than coordinate conversion
            let closestCell = null;
            let closestDistance = Infinity;
            
            for (const cell of gameState.cells.values()) {
                const center = cell.getCenterWorld();
                const dx = x - center.x;
                const dy = y - center.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Check if point is inside hexagon
                if (pointInHexagon(x, y, center.x, center.y, HEX_SIZE)) {
                    return cell; // Found exact match
                }
                
                // Track closest cell as fallback
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestCell = cell;
                }
            }
            
            // If no exact match, return closest cell if it's reasonably close
            // This helps with edge cases where clicking near boundaries
            if (closestCell && closestDistance <= HEX_SIZE * 1.2) {
                return closestCell;
            }
            
            return null;
        }

        function onMouseDown(event) {
            if (gameState.gameOver || !gameState.isPlaying) return; // Don't allow input when game is over or not playing
            
            const coords = screenToGameCoords(event.clientX, event.clientY);
            
            const cell = getCellFromPosition(coords.x, coords.y);
            if (cell && cell.owner === 'player' && cell.units.length > 0) {
                gameState.selectedCell = cell;
                gameState.isDragging = true;
                
                // Create drag line
                gameState.dragLine = new PIXI.Graphics();
                app.stage.addChild(gameState.dragLine);
            }
        }

        function onMouseMove(event) {
            if (gameState.isDragging && gameState.selectedCell) {
                const coords = screenToGameCoords(event.clientX, event.clientY);
                
                // Draw line from selected cell to mouse
                const start = gameState.selectedCell.getCenterWorld();
                gameState.dragLine.clear();
                gameState.dragLine.lineStyle(3, 0xFFFFFF, 0.5);
                gameState.dragLine.moveTo(start.x, start.y);
                gameState.dragLine.lineTo(coords.x, coords.y);
            }
        }

        function onMouseUp(event) {
            if (gameState.isDragging && gameState.selectedCell) {
                const coords = screenToGameCoords(event.clientX, event.clientY);
                
                const targetCell = getCellFromPosition(coords.x, coords.y);
                if (targetCell && targetCell !== gameState.selectedCell) {
                    // Send units
                    const unitsToSend = gameState.selectedCell.units.filter(u => u.owner === 'player');
                    unitsToSend.forEach(unit => {
                        unit.moveTo(targetCell);
                    });
                }
                
                // Clean up
                if (gameState.dragLine) {
                    app.stage.removeChild(gameState.dragLine);
                    gameState.dragLine.destroy();
                    gameState.dragLine = null;
                }
                gameState.selectedCell = null;
                gameState.isDragging = false;
            }
        }

        // Touch event handlers
        function onTouchStart(event) {
            event.preventDefault(); // Prevent scrolling and zooming
            if (gameState.gameOver || !gameState.isPlaying) return; // Don't allow input when game is over or not playing
            
            const touch = event.touches[0];
            const coords = screenToGameCoords(touch.clientX, touch.clientY);
            
            const cell = getCellFromPosition(coords.x, coords.y);
            if (cell && cell.owner === 'player' && cell.units.length > 0) {
                gameState.selectedCell = cell;
                gameState.isDragging = true;
                
                // Create drag line
                gameState.dragLine = new PIXI.Graphics();
                app.stage.addChild(gameState.dragLine);
            }
        }

        function onTouchMove(event) {
            event.preventDefault(); // Prevent scrolling
            if (gameState.isDragging && gameState.selectedCell) {
                const touch = event.touches[0];
                const coords = screenToGameCoords(touch.clientX, touch.clientY);
                
                // Draw line from selected cell to touch point
                const start = gameState.selectedCell.getCenterWorld();
                gameState.dragLine.clear();
                gameState.dragLine.lineStyle(3, 0xFFFFFF, 0.5);
                gameState.dragLine.moveTo(start.x, start.y);
                gameState.dragLine.lineTo(coords.x, coords.y);
            }
        }

        function onTouchEnd(event) {
            event.preventDefault(); // Prevent any default behavior
            if (gameState.isDragging && gameState.selectedCell) {
                const touch = event.changedTouches[0] || event.touches[0];
                const coords = screenToGameCoords(touch.clientX, touch.clientY);
                
                const targetCell = getCellFromPosition(coords.x, coords.y);
                if (targetCell && targetCell !== gameState.selectedCell) {
                    // Send units
                    const unitsToSend = gameState.selectedCell.units.filter(u => u.owner === 'player');
                    unitsToSend.forEach(unit => {
                        unit.moveTo(targetCell);
                    });
                }
                
                // Clean up
                if (gameState.dragLine) {
                    app.stage.removeChild(gameState.dragLine);
                    gameState.dragLine.destroy();
                    gameState.dragLine = null;
                }
                gameState.selectedCell = null;
                gameState.isDragging = false;
            }
        }

        // Update UI
        function updateUI() {
            const playerUnits = gameState.units.filter(u => u.owner === 'player').length;
            const enemyUnits = gameState.units.filter(u => u.owner === 'enemy').length;
            
            document.getElementById('playerUnits').textContent = playerUnits;
            document.getElementById('enemyUnits').textContent = enemyUnits;
            
            // Update score (tiles owned)
            const blueTiles = countOwnedCells('player');
            const redTiles = countOwnedCells('enemy');
            document.getElementById('blueTiles').textContent = blueTiles;
            document.getElementById('redTiles').textContent = redTiles;
        }

        // Simple AI for enemy
        function updateAI(dt) {
            if (gameState.gameOver || !gameState.isPlaying) return; // Don't update AI if game is over or not playing
            
            // Initialize delay on first call
            if (gameState.aiNextMoveDelay === 0) {
                // Random delay based on difficulty: Baby = 2.5-4.5, Normal = 2-4, Hard = 1.5-3.5, God = 1-3
                const lowerBound = 2.5 - (DIFFICULTY_LEVEL * 0.5);
                gameState.aiNextMoveDelay = (lowerBound + Math.random() * 2) / GAME_SPEED;
            }
            
            // Check if it's time to make a move
            gameState.aiMoveTimer += dt;
            if (gameState.aiMoveTimer >= gameState.aiNextMoveDelay) {
                gameState.aiMoveTimer = 0;
                
                const enemyCells = [];
                for (const cell of gameState.cells.values()) {
                    if (cell.owner === 'enemy' && cell.units.length > 0) {
                        enemyCells.push(cell);
                    }
                }
                
                if (enemyCells.length > 0) {
                    const fromCell = enemyCells[Math.floor(Math.random() * enemyCells.length)];
                    const adjacentCells = [];
                    
                    // Get adjacent hex cells (6 neighbors)
                    const neighbors = getHexNeighbors(fromCell.q, fromCell.r);
                    neighbors.forEach(neighbor => {
                        if (isHexInBounds(neighbor.q, neighbor.r, GRID_SIZE)) {
                            const cell = getCellByHex(neighbor.q, neighbor.r);
                            if (cell) {
                                adjacentCells.push(cell);
                            }
                        }
                    });
                    
                    if (adjacentCells.length > 0) {
                        const toCell = adjacentCells[Math.floor(Math.random() * adjacentCells.length)];
                        const unitsToSend = fromCell.units.filter(u => u.owner === 'enemy');
                        unitsToSend.forEach(unit => {
                            unit.moveTo(toCell);
                        });
                    }
                }
                
                // Set next random delay based on difficulty: Baby = 2.5-4.5, Normal = 2-4, Hard = 1.5-3.5, God = 1-3
                const lowerBound = 2.5 - (DIFFICULTY_LEVEL * 0.5);
                gameState.aiNextMoveDelay = (lowerBound + Math.random() * 2) / GAME_SPEED;
            }
        }

        // Count owned cells
        function countOwnedCells(owner) {
            let count = 0;
            for (const cell of gameState.cells.values()) {
                if (cell.owner === owner) {
                    count++;
                }
            }
            return count;
        }

        // Spawn units
        function spawnUnits(dt) {
            if (gameState.gameOver || !gameState.isPlaying) return; // Don't spawn if game is over or not playing
            
            // Player spawning - find player spawn cell (maximum q+r)
            gameState.playerSpawnTimer += dt;
            const playerCells = countOwnedCells('player');
            const playerSpawnRate = Math.max(0.5 / GAME_SPEED, BASE_SPAWN_RATE - (playerCells * SPAWN_RATE_PER_CELL));
            
            if (gameState.playerSpawnTimer >= playerSpawnRate) {
                gameState.playerSpawnTimer = 0;
                let spawnCell = null;
                let maxSum = -Infinity;
                for (const cell of gameState.cells.values()) {
                    const sum = cell.q + cell.r;
                    if (sum > maxSum) {
                        maxSum = sum;
                        spawnCell = cell;
                    }
                }
                if (spawnCell && spawnCell.owner === 'player') {
                    const unit = new Unit('player', spawnCell);
                    gameState.units.push(unit);
                    gameState.playerTotalUnitsProduced++;
                }
            }
            
            // Enemy spawning - find enemy spawn cell (top-left corner)
            // Find the topmost cell (minimum r), then leftmost (minimum q)
            gameState.enemySpawnTimer += dt;
            const enemyCells = countOwnedCells('enemy');
            const baseEnemySpawnRate = Math.max(0.5 / GAME_SPEED, BASE_SPAWN_RATE - (enemyCells * SPAWN_RATE_PER_CELL));
            // Apply difficulty multiplier (divide by multiplier to spawn faster at higher difficulty)
            const enemySpawnRate = baseEnemySpawnRate / getEnemyDifficultyMultiplier();
            
            if (gameState.enemySpawnTimer >= enemySpawnRate) {
                gameState.enemySpawnTimer = 0;
                let spawnCell = null;
                let minR = Infinity;
                for (const cell of gameState.cells.values()) {
                    if (cell.r < minR) {
                        minR = cell.r;
                        spawnCell = cell;
                    } else if (cell.r === minR && spawnCell && cell.q < spawnCell.q) {
                        spawnCell = cell;
                    }
                }
                if (spawnCell && spawnCell.owner === 'enemy') {
                    const unit = new Unit('enemy', spawnCell);
                    gameState.units.push(unit);
                    gameState.enemyTotalUnitsProduced++;
                }
            }
        }

        // Check for win/lose conditions
        function checkGameOver() {
            if (gameState.gameOver || !gameState.isPlaying) return; // Already game over or not playing
            
            const totalCells = gameState.cells.size;
            const playerCells = countOwnedCells('player');
            const enemyCells = countOwnedCells('enemy');
            
            if (playerCells === totalCells) {
                gameState.gameOver = true;
                gameState.isPlaying = false;
                
                // If player won on Hard difficulty, unlock God mode
                if (DIFFICULTY_LEVEL === 2) {
                    localStorage.setItem('hardBeaten', 'true');
                    updateDifficultySelector();
                }
                
                updateDifficultyButtonsState();
                
                setTimeout(() => {
                    alert('You win!');
                }, 100);
            } else if (enemyCells === totalCells) {
                gameState.gameOver = true;
                gameState.isPlaying = false;
                updateDifficultyButtonsState();
                setTimeout(() => {
                    alert('You lose!');
                }, 100);
            }
        }

        // Restart the game
        function restartGame() {
            // Clean up all units
            gameState.units.forEach(unit => {
                unit.destroy();
            });
            
            // Clean up all cells
            for (const cell of gameState.cells.values()) {
                app.stage.removeChild(cell.container);
                cell.container.destroy({ children: true });
            }
            
            // Clean up drag line if it exists
            if (gameState.dragLine) {
                app.stage.removeChild(gameState.dragLine);
                gameState.dragLine.destroy();
                gameState.dragLine = null;
            }
            
            // Reset game state
            gameState.cells = [];
            gameState.units = [];
            gameState.selectedCell = null;
            gameState.isDragging = false;
            gameState.playerSpawnTimer = 0;
            gameState.enemySpawnTimer = 0;
            gameState.aiMoveTimer = 0;
            gameState.aiNextMoveDelay = 0;
            gameState.playerTotalUnitsProduced = 0;
            gameState.enemyTotalUnitsProduced = 0;
            gameState.gameOver = false;
            gameState.isPlaying = true;
            
            // Reinitialize
            initGrid();
            initUnits();
            updateUI();
            updateDifficultyButtonsState(); // Disable buttons when game starts
        }

        // Start a new game
        function startNewGame() {
            restartGame();
        }

        // Game loop
        app.ticker.add((ticker) => {
            if (!gameState.isPlaying) return; // Don't update game if not playing
            
            // Get delta time in seconds (PixiJS ticker.elapsedMS is in milliseconds)
            // Clamp delta time to prevent huge jumps on first frame or lag spikes
            const rawDt = (ticker.elapsedMS || 16.67) / 1000; // Default to ~60fps if undefined
            const dt = Math.min(rawDt, 0.1); // Cap at 100ms (10fps minimum) to prevent issues
            
            // Update all units
            gameState.units.forEach(unit => {
                unit.update(ticker.elapsedMS || 16.67);
            });
            
            // Handle unit conflicts and capture progress
            for (const cell of gameState.cells.values()) {
                const playerUnits = cell.units.filter(u => u.owner === 'player');
                const enemyUnits = cell.units.filter(u => u.owner === 'enemy');
                
                // Combat: units destroy each other
                if (playerUnits.length > 0 && enemyUnits.length > 0) {
                    const minCount = Math.min(playerUnits.length, enemyUnits.length);
                    
                    for (let i = 0; i < minCount; i++) {
                        // Remove units
                        const pUnit = playerUnits[i];
                        const eUnit = enemyUnits[i];
                        
                        pUnit.destroy();
                        eUnit.destroy();
                        
                        gameState.units = gameState.units.filter(u => u !== pUnit && u !== eUnit);
                        cell.units = cell.units.filter(u => u !== pUnit && u !== eUnit);
                    }
                }
                
                // Update capture progress and unit count
                cell.updateCaptureProgress(dt);
                cell.updateUnitCount();
            }
            
            // Spawn units based on owned cells
            spawnUnits(dt);
            
            updateAI(dt);
            updateUI();
            
            // Check for win/lose conditions
            checkGameOver();
        });

        // Update selected button state
        function updateSelectedButton() {
            const buttons = document.querySelectorAll('.difficultyButton');
            buttons.forEach(button => {
                const level = parseInt(button.getAttribute('data-level'));
                if (level === DIFFICULTY_LEVEL) {
                    button.classList.add('selected');
                } else {
                    button.classList.remove('selected');
                }
            });
        }

        // Update difficulty buttons enabled/disabled state based on game state
        function updateDifficultyButtonsState() {
            const buttons = document.querySelectorAll('.difficultyButton');
            buttons.forEach(button => {
                // Disable if game is playing, but preserve the unlock state for God button
                if (gameState.isPlaying) {
                    button.disabled = true;
                } else {
                    // Re-enable, but check unlock status for God button
                    const level = parseInt(button.getAttribute('data-level'));
                    if (level === 3) {
                        const hardBeaten = localStorage.getItem('hardBeaten') === 'true';
                        button.disabled = !hardBeaten;
                    } else {
                        button.disabled = false;
                    }
                }
            });
        }

        // Update difficulty selector based on unlock status
        function updateDifficultySelector() {
            const hardBeaten = localStorage.getItem('hardBeaten') === 'true';
            
            // If God is currently selected but not unlocked, switch to Normal
            if (!hardBeaten && DIFFICULTY_LEVEL === 3) {
                DIFFICULTY_LEVEL = 1;
                updateSelectedButton();
            }
            
            // Update button states (handles both unlock status and game playing state)
            updateDifficultyButtonsState();
        }

        // Setup difficulty buttons
        const difficultyButtons = document.querySelectorAll('.difficultyButton');
        difficultyButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                if (button.disabled || gameState.isPlaying) return;
                DIFFICULTY_LEVEL = parseInt(button.getAttribute('data-level'));
                updateSelectedButton();
            });
        });

        // Setup New Game button
        document.getElementById('newGameButton').addEventListener('click', startNewGame);

        // Initialize difficulty selector on page load
        updateSelectedButton();
        updateDifficultySelector();

        // Initialize game (but don't start playing)
        initGrid();
        setupInput();
        updateUI();
    </script>
</body>
</html>