<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zone Control</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
        }
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 100vw;
            padding: 10px;
            box-sizing: border-box;
        }
        #info {
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            margin-bottom: 10px;
            width: 100%;
            max-width: 500px;
            box-sizing: border-box;
        }
        #difficultySelector {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        #difficultySelector label {
            color: white;
            font-size: 14px;
            font-weight: bold;
        }
        .difficultyButton {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid #4A90E2;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .difficultyButton:hover:not(:disabled) {
            background: rgba(74, 144, 226, 0.3);
            border-color: #357ABD;
        }
        .difficultyButton.selected {
            background: #4A90E2;
            border-color: #357ABD;
        }
        .difficultyButton:disabled {
            color: #888;
            cursor: not-allowed;
            opacity: 0.5;
            font-style: italic;
        }
        #newGameButton {
            background: #4A90E2;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 10px;
            transition: background 0.3s;
        }
        #newGameButton:hover {
            background: #357ABD;
        }
        #newGameButton:active {
            background: #2E5C8A;
        }
        canvas {
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            max-width: 100%;
            max-height: calc(100vh - 200px);
            width: auto;
            height: auto;
        }
        @media (max-width: 600px) {
            #info {
                font-size: 12px;
                padding: 8px;
            }
            body {
                padding: 5px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="difficultySelector">
            <label>Difficulty:</label>
            <button class="difficultyButton" data-level="0">Baby</button>
            <button class="difficultyButton selected" data-level="1">Normal</button>
            <button class="difficultyButton" data-level="2">Hard</button>
            <button class="difficultyButton" data-level="3" id="godButton" disabled>God</button>
        </div>
        <button id="newGameButton">New Game</button>
        <div id="info">
            <div>Player Units: <span id="playerUnits">0</span></div>
            <div>Enemy Units: <span id="enemyUnits">0</span></div>
            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255, 255, 255, 0.3);">
                <div>Blue Tiles: <span id="blueTiles">0</span></div>
                <div>Red Tiles: <span id="redTiles">0</span></div>
            </div>
            <div style="margin-top: 10px; font-size: 12px;">
                Click and drag from your cells to send units!<br>
                The more zones you control, the faster you gain units.
            </div>
        </div>
    </div>

    <script>
        // Game configuration
        const GRID_SIZE = 5;
        const CELL_SIZE = 100;
        const UNIT_RADIUS = 4;
        const GAME_SPEED = 1.75; // Game speed multiplier (1.0 = normal speed)
        const UNIT_SPEED = 69 * GAME_SPEED; // Pixels per second
        const UNIT_WANDER_SPEED = 21 * GAME_SPEED; // Pixels per second
        const UNIT_WANDER_RADIUS = 40;
        const BASE_SPAWN_RATE = 4.5 / GAME_SPEED; // Seconds between spawns (at 60fps, 270 frames = 4.5 seconds)
        const SPAWN_RATE_PER_CELL = 0.15 / GAME_SPEED; // Seconds faster spawn per owned cell (at 60fps, 9 frames = 0.15 seconds)
        const CAPTURE_RATE = 9 * GAME_SPEED; // How fast cells are captured/neutralized per second (higher = faster)

        // Difficulty level (0 = Baby, 1 = Normal, 2 = Hard, 3 = God)
        let DIFFICULTY_LEVEL = 1; // Default to Normal

        // Colors
        const COLORS = {
            NEUTRAL: 0xFFFFFF,
            PLAYER: 0x4A90E2,
            ENEMY: 0xE74C3C,
            GRID: 0x2C3E50,
            UNIT_PLAYER: 0x2E5C8A,
            UNIT_ENEMY: 0xA93226,
            SHIELD: 0xFFD700 // Gold color for shield
        };

        // Initialize PixiJS application
        const app = new PIXI.Application({
            width: GRID_SIZE * CELL_SIZE,
            height: GRID_SIZE * CELL_SIZE,
            backgroundColor: 0x16213e,
            antialias: true,
            resolution: window.devicePixelRatio || 1,
            autoDensity: true
        });
        document.getElementById('gameContainer').appendChild(app.view);
        
        // Base values for info panel (scoreboard)
        const INFO_BASE_FONT_SIZE = 14;
        const INFO_BASE_PADDING = 10;
        const INFO_BASE_MAX_WIDTH = 500;
        const INFO_BASE_BORDER_RADIUS = 5;
        
        // Function to scale canvas to fit viewport on mobile
        function scaleCanvas() {
            const canvas = app.view;
            const container = document.getElementById('gameContainer');
            const info = document.getElementById('info');
            
            const gameWidth = GRID_SIZE * CELL_SIZE;
            const gameHeight = GRID_SIZE * CELL_SIZE;
            
            // Get available space (accounting for info panel and padding)
            const infoHeight = info.offsetHeight;
            const padding = 20;
            const availableWidth = window.innerWidth - padding;
            const availableHeight = window.innerHeight - infoHeight - padding - 20;
            
            // Calculate scale to fit both width and height
            const scaleX = availableWidth / gameWidth;
            const scaleY = availableHeight / gameHeight;
            const scale = Math.min(scaleX, scaleY, 1); // Don't scale up on desktop
            
            // Apply scaling to canvas
            if (scale < 1) {
                canvas.style.width = (gameWidth * scale) + 'px';
                canvas.style.height = (gameHeight * scale) + 'px';
            } else {
                // On desktop, use original size
                canvas.style.width = gameWidth + 'px';
                canvas.style.height = gameHeight + 'px';
            }
            
            // Apply same scaling to info panel (scoreboard)
            const BASE_SPACING = 10;
            const BASE_INSTRUCTION_FONT = 12;
            
            if (scale < 1) {
                info.style.fontSize = (INFO_BASE_FONT_SIZE * scale) + 'px';
                info.style.padding = (INFO_BASE_PADDING * scale) + 'px';
                info.style.maxWidth = (INFO_BASE_MAX_WIDTH * scale) + 'px';
                info.style.borderRadius = (INFO_BASE_BORDER_RADIUS * scale) + 'px';
                info.style.marginBottom = (BASE_SPACING * scale) + 'px';
                
                // Scale spacing in child divs (margin-top and padding-top)
                const childDivs = info.querySelectorAll('div > div');
                childDivs.forEach(div => {
                    if (div.style.marginTop && div.style.marginTop.includes('px')) {
                        div.style.marginTop = (BASE_SPACING * scale) + 'px';
                    }
                    if (div.style.paddingTop && div.style.paddingTop.includes('px')) {
                        div.style.paddingTop = (BASE_SPACING * scale) + 'px';
                    }
                });
                
                // Scale the instruction text font size
                const instructionDiv = info.querySelector('div:last-child');
                if (instructionDiv && instructionDiv.style.fontSize) {
                    instructionDiv.style.fontSize = (BASE_INSTRUCTION_FONT * scale) + 'px';
                }
            } else {
                // Reset to original values on desktop
                info.style.fontSize = INFO_BASE_FONT_SIZE + 'px';
                info.style.padding = INFO_BASE_PADDING + 'px';
                info.style.maxWidth = INFO_BASE_MAX_WIDTH + 'px';
                info.style.borderRadius = INFO_BASE_BORDER_RADIUS + 'px';
                info.style.marginBottom = BASE_SPACING + 'px';
                
                // Reset spacing in child divs
                const childDivs = info.querySelectorAll('div > div');
                childDivs.forEach(div => {
                    if (div.style.marginTop && div.style.marginTop.includes('px')) {
                        div.style.marginTop = BASE_SPACING + 'px';
                    }
                    if (div.style.paddingTop && div.style.paddingTop.includes('px')) {
                        div.style.paddingTop = BASE_SPACING + 'px';
                    }
                });
                
                const instructionDiv = info.querySelector('div:last-child');
                if (instructionDiv && instructionDiv.style.fontSize) {
                    instructionDiv.style.fontSize = BASE_INSTRUCTION_FONT + 'px';
                }
            }
        }
        
        // Scale on load and resize
        scaleCanvas();
        window.addEventListener('resize', scaleCanvas);
        window.addEventListener('orientationchange', () => {
            setTimeout(scaleCanvas, 100); // Small delay for orientation change
        });

        // Game state
        const gameState = {
            cells: [],
            units: [],
            selectedCell: null,
            dragLine: null,
            isDragging: false,
            playerSpawnTimer: 0,
            enemySpawnTimer: 0,
            aiMoveTimer: 0,
            aiNextMoveDelay: 0,
            playerTotalUnitsProduced: 0,
            enemyTotalUnitsProduced: 0,
            gameOver: false,
            isPlaying: false
        };

        // Cell class
        class Cell {
            constructor(row, col) {
                this.row = row;
                this.col = col;
                this.owner = 'neutral'; // 'neutral', 'player', 'enemy'
                this.units = [];
                this.captureProgress = 0; // 0 to 100, progress towards capturing
                this.capturingOwner = null; // Who is trying to capture this cell
                this.hasShield = false; // Whether this cell has a shield
                this.shieldProgress = 0; // 0 to 100, progress towards breaking shield
                this.shieldConsumeTimer = 0; // Timer for consuming units (1 unit per second)
                
                // Create cell graphics
                this.container = new PIXI.Container();
                this.container.x = col * CELL_SIZE;
                this.container.y = row * CELL_SIZE;
                
                // Background
                this.bg = new PIXI.Graphics();
                this.updateColor();
                this.container.addChild(this.bg);
                
                // Border
                this.border = new PIXI.Graphics();
                this.border.lineStyle(2, COLORS.GRID, 1);
                this.border.drawRect(0, 0, CELL_SIZE, CELL_SIZE);
                this.container.addChild(this.border);
                
                // Capture progress bar
                this.progressBar = new PIXI.Graphics();
                this.container.addChild(this.progressBar);
                
                // Unit count text
                this.unitText = new PIXI.Text('', {
                    fontFamily: 'Arial',
                    fontSize: 20,
                    fill: 0x000000,
                    fontWeight: 'bold'
                });
                this.unitText.anchor.set(0.5);
                this.unitText.x = CELL_SIZE / 2;
                this.unitText.y = CELL_SIZE / 2;
                this.container.addChild(this.unitText);
                
                // Make interactive
                this.container.interactive = true;
                this.container.buttonMode = true;
                
                app.stage.addChild(this.container);
            }
            
            updateColor() {
                this.bg.clear();
                let color = COLORS.NEUTRAL;
                if (this.owner === 'player') color = COLORS.PLAYER;
                else if (this.owner === 'enemy') color = COLORS.ENEMY;
                
                // Draw normal background
                this.bg.beginFill(color, 0.6);
                this.bg.drawRect(0, 0, CELL_SIZE, CELL_SIZE);
                this.bg.endFill();
                
                // Update border color - gold if shield, normal grid color otherwise
                // Only update if border exists (it's created after updateColor in constructor)
                if (this.border) {
                    this.border.clear();
                    const borderColor = this.hasShield ? COLORS.SHIELD : COLORS.GRID;
                    this.border.lineStyle(2, borderColor, 1);
                    this.border.drawRect(0, 0, CELL_SIZE, CELL_SIZE);
                }
            }
            
            updateCaptureProgress(dt) {
                const playerUnits = this.units.filter(u => u.owner === 'player').length;
                const enemyUnits = this.units.filter(u => u.owner === 'enemy').length;
                
                // Determine who has more units
                let dominantOwner = null;
                let unitAdvantage = 0;
                
                if (playerUnits > enemyUnits) {
                    dominantOwner = 'player';
                    unitAdvantage = playerUnits - enemyUnits;
                } else if (enemyUnits > playerUnits) {
                    dominantOwner = 'enemy';
                    unitAdvantage = enemyUnits - playerUnits;
                }
                
                // Handle shield logic first
                if (this.hasShield) {
                    // Determine if shield is being attacked
                    // Shield protects the cell's owner, so it's attacked when opponent has more units
                    const isShieldAttacked = dominantOwner && dominantOwner !== this.owner && unitAdvantage > 0;
                    
                    if (isShieldAttacked) {
                        // Shield is being attacked - break it (5x slower)
                        this.shieldProgress += unitAdvantage * (CAPTURE_RATE / 5) * dt;
                        
                        // Consume 1 unit per second from attacking units
                        // Track accumulated time for unit consumption
                        this.shieldConsumeTimer += dt;
                        if (this.shieldConsumeTimer >= 1.0) {
                            this.shieldConsumeTimer = 0;
                            const attackingUnits = this.units.filter(u => u.owner === dominantOwner);
                            if (attackingUnits.length > 0) {
                                const unit = attackingUnits[0];
                                unit.destroy();
                                gameState.units = gameState.units.filter(u => u !== unit);
                                this.units = this.units.filter(u => u !== unit);
                            }
                        }
                        
                        if (this.shieldProgress >= 100) {
                            // Shield broken! Keep the owner, let normal capture logic handle owner -> neutral -> new owner
                            this.hasShield = false;
                            this.shieldProgress = 0;
                            this.shieldConsumeTimer = 0; // Reset timer
                            // Don't change owner - let it show the original owner's color first
                            // Then normal capture logic will neutralize it, then capture it
                            this.captureProgress = 100; // Set to 100 so it shows as fully owned
                            this.updateColor();
                        }
                    } else {
                        // Shield not being attacked - decay shield progress and reset timer
                        if (this.shieldProgress > 0) {
                            this.shieldProgress -= 12 * GAME_SPEED * dt;
                            if (this.shieldProgress < 0) this.shieldProgress = 0;
                        }
                        this.shieldConsumeTimer = 0; // Reset timer when not being attacked
                    }
                    
                    // Draw shield progress bar
                    this.progressBar.clear();
                    if (this.shieldProgress > 0 && this.shieldProgress < 100) {
                        const barWidth = (CELL_SIZE - 10) * (this.shieldProgress / 100);
                        // Background
                        this.progressBar.beginFill(0x000000, 0.3);
                        this.progressBar.drawRect(5, CELL_SIZE - 15, CELL_SIZE - 10, 10);
                        this.progressBar.endFill();
                        // Shield progress (gold)
                        this.progressBar.beginFill(COLORS.SHIELD, 0.8);
                        this.progressBar.drawRect(5, CELL_SIZE - 15, barWidth, 10);
                        this.progressBar.endFill();
                    }
                    return; // Shield logic handled, exit early
                }
                
                // Normal capture logic (when no shield)
                // If cell is already owned by dominant owner, maintain ownership
                if (dominantOwner === this.owner) {
                    this.captureProgress = 100;
                    this.capturingOwner = null;
                }
                // If cell is owned but has no units, keep the ownership (don't turn neutral)
                else if (this.owner !== 'neutral' && playerUnits === 0 && enemyUnits === 0) {
                    // Keep current ownership when cell is empty
                    this.captureProgress = 100;
                    this.capturingOwner = null;
                }
                // If cell is neutral and empty, stay neutral
                else if (this.owner === 'neutral' && playerUnits === 0 && enemyUnits === 0) {
                    this.captureProgress = 0;
                    this.capturingOwner = null;
                }
                // If someone else is dominant, start/continue capture
                else if (dominantOwner && dominantOwner !== this.owner) {
                    // If this is a new capturer or continuing neutralization, set capturing owner
                    if (this.capturingOwner !== dominantOwner) {
                        this.capturingOwner = dominantOwner;
                    }
                    
                    // If cell is owned by opponent, first neutralize it
                    if (this.owner !== 'neutral') {
                        // Decrease progress (neutralizing the cell)
                        this.captureProgress -= unitAdvantage * CAPTURE_RATE * dt;
                        
                        if (this.captureProgress <= 0) {
                            this.owner = 'neutral';
                            this.captureProgress = 0;
                            this.updateColor();
                        }
                    } else {
                        // Cell is neutral, now capture it
                        this.captureProgress += unitAdvantage * CAPTURE_RATE * dt;
                        
                        if (this.captureProgress >= 100) {
                            this.captureProgress = 100;
                            this.owner = dominantOwner;
                            this.capturingOwner = null;
                            this.updateColor();
                        }
                    }
                }
                // Equal units or no dominant owner, but cell is owned - keep ownership
                else if (this.owner !== 'neutral') {
                    this.captureProgress = 100;
                    this.capturingOwner = null;
                }
                // Neutral cell with equal or no units
                else {
                // Slowly decay capture progress
                // Original was 0.2 per frame at 60fps = 12 per second
                if (this.captureProgress > 0) {
                    this.captureProgress -= 12 * GAME_SPEED * dt;
                    if (this.captureProgress < 0) this.captureProgress = 0;
                }
                    if (this.captureProgress === 0) {
                        this.capturingOwner = null;
                    }
                }
                
                // Draw progress bar
                this.progressBar.clear();
                
                // Show progress bar during neutralization (owned -> neutral)
                if (this.owner !== 'neutral' && this.capturingOwner && this.capturingOwner !== this.owner) {
                    const barWidth = (CELL_SIZE - 10) * (this.captureProgress / 100);
                    let barColor = this.owner === 'player' ? COLORS.PLAYER : COLORS.ENEMY;
                    
                    // Background
                    this.progressBar.beginFill(0x000000, 0.3);
                    this.progressBar.drawRect(5, CELL_SIZE - 15, CELL_SIZE - 10, 10);
                    this.progressBar.endFill();
                    
                    // Progress (shows how much ownership remains)
                    this.progressBar.beginFill(barColor, 0.8);
                    this.progressBar.drawRect(5, CELL_SIZE - 15, barWidth, 10);
                    this.progressBar.endFill();
                }
                // Show progress bar during capture (neutral -> owned)
                else if (this.captureProgress > 0 && this.captureProgress < 100 && this.owner === 'neutral' && this.capturingOwner) {
                    const barWidth = (CELL_SIZE - 10) * (this.captureProgress / 100);
                    let barColor = this.capturingOwner === 'player' ? COLORS.PLAYER : COLORS.ENEMY;
                    
                    // Background
                    this.progressBar.beginFill(0x000000, 0.3);
                    this.progressBar.drawRect(5, CELL_SIZE - 15, CELL_SIZE - 10, 10);
                    this.progressBar.endFill();
                    
                    // Progress
                    this.progressBar.beginFill(barColor, 0.8);
                    this.progressBar.drawRect(5, CELL_SIZE - 15, barWidth, 10);
                    this.progressBar.endFill();
                }
            }
            
            updateUnitCount() {
                const count = this.units.length;
                this.unitText.text = count > 0 ? count.toString() : '';
            }
            
            getCenterWorld() {
                return {
                    x: this.col * CELL_SIZE + CELL_SIZE / 2,
                    y: this.row * CELL_SIZE + CELL_SIZE / 2
                };
            }
        }

        // Unit class
        class Unit {
            constructor(owner, cell) {
                this.owner = owner; // 'player' or 'enemy'
                this.cell = cell;
                this.isMoving = false;
                this.targetCell = null;
                
                // Graphics
                this.graphics = new PIXI.Graphics();
                this.graphics.lineStyle(1, 0xFFFFFF, 1); // White outline
                this.graphics.beginFill(owner === 'player' ? COLORS.UNIT_PLAYER : COLORS.UNIT_ENEMY);
                this.graphics.drawCircle(0, 0, UNIT_RADIUS);
                this.graphics.endFill();
                
                // Position in cell
                const center = cell.getCenterWorld();
                this.x = center.x;
                this.y = center.y;
                
                // Wandering behavior - velocity-based steering
                this.velocityAngle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(this.velocityAngle) * UNIT_WANDER_SPEED;
                this.vy = Math.sin(this.velocityAngle) * UNIT_WANDER_SPEED;
                
                this.updatePosition();
                app.stage.addChild(this.graphics);
                
                // Add to cell
                cell.units.push(this);
            }
            
            updatePosition() {
                this.graphics.x = this.x;
                this.graphics.y = this.y;
            }
            
            wander(dt) {
                if (this.isMoving) return;
                
                const center = this.cell.getCenterWorld();
                // Allow movement in most of the cell, leaving small margin for boundaries
                const cellMinX = this.cell.col * CELL_SIZE + UNIT_RADIUS + 5;
                const cellMaxX = (this.cell.col + 1) * CELL_SIZE - UNIT_RADIUS - 5;
                const cellMinY = this.cell.row * CELL_SIZE + UNIT_RADIUS + 5;
                const cellMaxY = (this.cell.row + 1) * CELL_SIZE - UNIT_RADIUS - 5;
                
                // Calculate distance from center
                const distFromCenterX = this.x - center.x;
                const distFromCenterY = this.y - center.y;
                const distFromCenter = Math.sqrt(distFromCenterX * distFromCenterX + distFromCenterY * distFromCenterY);
                
                // Steering behavior: gradually change direction (random wander)
                // Original was 0.08 per frame at 60fps = 4.8 per second
                this.velocityAngle += (Math.random() - 0.5) * 4.8 * GAME_SPEED * dt;
                
                // Steer away from boundaries smoothly (only when very close)
                const margin = 8;
                let steerX = 0;
                let steerY = 0;
                
                if (this.x < cellMinX + margin) {
                    steerX = 1; // Steer right
                } else if (this.x > cellMaxX - margin) {
                    steerX = -1; // Steer left
                }
                
                if (this.y < cellMinY + margin) {
                    steerY = 1; // Steer down
                } else if (this.y > cellMaxY - margin) {
                    steerY = -1; // Steer up
                }
                
                // Apply boundary steering (gentler)
                if (steerX !== 0 || steerY !== 0) {
                    const desiredAngle = Math.atan2(steerY, steerX);
                    this.velocityAngle = this.velocityAngle * 0.9 + desiredAngle * 0.1;
                }
                
                // Only gently steer back towards center if very far (much less aggressive)
                if (distFromCenter > UNIT_WANDER_RADIUS * 1.2) {
                    const angleToCenter = Math.atan2(-distFromCenterY, -distFromCenterX);
                    this.velocityAngle = this.velocityAngle * 0.95 + angleToCenter * 0.05;
                }
                
                // Update velocity based on angle
                this.vx = Math.cos(this.velocityAngle) * UNIT_WANDER_SPEED;
                this.vy = Math.sin(this.velocityAngle) * UNIT_WANDER_SPEED;
                
                // Move based on velocity (scaled by delta time)
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                
                // Clamp position to cell bounds
                this.x = Math.max(cellMinX, Math.min(cellMaxX, this.x));
                this.y = Math.max(cellMinY, Math.min(cellMaxY, this.y));
                
                this.updatePosition();
            }
            
            moveTo(targetCell) {
                this.isMoving = true;
                this.targetCell = targetCell;
                
                // Remove from current cell
                const index = this.cell.units.indexOf(this);
                if (index > -1) {
                    this.cell.units.splice(index, 1);
                }
                this.cell = null;
            }
            
            update(deltaTime) {
                const dt = deltaTime / 1000; // Convert milliseconds to seconds
                
                if (this.isMoving && this.targetCell) {
                    const target = this.targetCell.getCenterWorld();
                    const dx = target.x - this.x;
                    const dy = target.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    const moveDistance = UNIT_SPEED * dt;
                    if (dist < moveDistance) {
                        // Arrived at destination
                        this.x = target.x;
                        this.y = target.y;
                        this.isMoving = false;
                        this.cell = this.targetCell;
                        this.targetCell.units.push(this);
                        this.targetCell = null;
                        
                        // Reset wander - initialize velocity-based steering
                        this.velocityAngle = Math.random() * Math.PI * 2;
                        this.vx = Math.cos(this.velocityAngle) * UNIT_WANDER_SPEED;
                        this.vy = Math.sin(this.velocityAngle) * UNIT_WANDER_SPEED;
                    } else {
                        // Move towards target
                        this.x += (dx / dist) * moveDistance;
                        this.y += (dy / dist) * moveDistance;
                    }
                    this.updatePosition();
                } else {
                    this.wander(dt);
                }
            }
            
            destroy() {
                app.stage.removeChild(this.graphics);
                this.graphics.destroy();
            }
        }

        // Initialize grid
        function initGrid() {
            for (let row = 0; row < GRID_SIZE; row++) {
                gameState.cells[row] = [];
                for (let col = 0; col < GRID_SIZE; col++) {
                    gameState.cells[row][col] = new Cell(row, col);
                }
            }
        }

        // Initialize units
        function initUnits() {
            // Player units in bottom right (4, 4)
            const playerCell = gameState.cells[4][4];
            for (let i = 0; i < 5; i++) {
                const unit = new Unit('player', playerCell);
                gameState.units.push(unit);
                gameState.playerTotalUnitsProduced++;
            }
            playerCell.owner = 'player';
            playerCell.hasShield = true; // Home tile starts with shield
            playerCell.shieldProgress = 0;
            playerCell.updateColor();
            
            // Enemy units in top left (0, 0)
            const enemyCell = gameState.cells[0][0];
            for (let i = 0; i < 5; i++) {
                const unit = new Unit('enemy', enemyCell);
                gameState.units.push(unit);
                gameState.enemyTotalUnitsProduced++;
            }
            enemyCell.owner = 'enemy';
            enemyCell.hasShield = true; // Home tile starts with shield
            enemyCell.shieldProgress = 0;
            enemyCell.updateColor();
        }

        // Input handling
        function setupInput() {
            // Mouse events
            app.view.addEventListener('mousedown', onMouseDown);
            app.view.addEventListener('mousemove', onMouseMove);
            app.view.addEventListener('mouseup', onMouseUp);
            
            // Touch events
            app.view.addEventListener('touchstart', onTouchStart, { passive: false });
            app.view.addEventListener('touchmove', onTouchMove, { passive: false });
            app.view.addEventListener('touchend', onTouchEnd, { passive: false });
            app.view.addEventListener('touchcancel', onTouchEnd, { passive: false });
        }

        // Helper function to convert screen coordinates to game coordinates
        function screenToGameCoords(screenX, screenY) {
            const canvas = app.view;
            const rect = canvas.getBoundingClientRect();
            
            // Get the actual canvas dimensions (game space)
            const gameWidth = GRID_SIZE * CELL_SIZE;
            const gameHeight = GRID_SIZE * CELL_SIZE;
            
            // Get the displayed canvas dimensions (CSS scaled)
            const displayWidth = rect.width;
            const displayHeight = rect.height;
            
            // Calculate scale factors
            const scaleX = gameWidth / displayWidth;
            const scaleY = gameHeight / displayHeight;
            
            // Convert screen coordinates to game coordinates
            const gameX = (screenX - rect.left) * scaleX;
            const gameY = (screenY - rect.top) * scaleY;
            
            return { x: gameX, y: gameY };
        }

        function getCellFromPosition(x, y) {
            const col = Math.floor(x / CELL_SIZE);
            const row = Math.floor(y / CELL_SIZE);
            if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
                return gameState.cells[row][col];
            }
            return null;
        }

        function onMouseDown(event) {
            if (gameState.gameOver || !gameState.isPlaying) return; // Don't allow input when game is over or not playing
            
            const coords = screenToGameCoords(event.clientX, event.clientY);
            
            const cell = getCellFromPosition(coords.x, coords.y);
            if (cell && cell.owner === 'player' && cell.units.length > 0) {
                gameState.selectedCell = cell;
                gameState.isDragging = true;
                
                // Create drag line
                gameState.dragLine = new PIXI.Graphics();
                app.stage.addChild(gameState.dragLine);
            }
        }

        function onMouseMove(event) {
            if (gameState.isDragging && gameState.selectedCell) {
                const coords = screenToGameCoords(event.clientX, event.clientY);
                
                // Draw line from selected cell to mouse
                const start = gameState.selectedCell.getCenterWorld();
                gameState.dragLine.clear();
                gameState.dragLine.lineStyle(3, 0xFFFFFF, 0.5);
                gameState.dragLine.moveTo(start.x, start.y);
                gameState.dragLine.lineTo(coords.x, coords.y);
            }
        }

        function onMouseUp(event) {
            if (gameState.isDragging && gameState.selectedCell) {
                const coords = screenToGameCoords(event.clientX, event.clientY);
                
                const targetCell = getCellFromPosition(coords.x, coords.y);
                if (targetCell && targetCell !== gameState.selectedCell) {
                    // Send units
                    const unitsToSend = gameState.selectedCell.units.filter(u => u.owner === 'player');
                    unitsToSend.forEach(unit => {
                        unit.moveTo(targetCell);
                    });
                }
                
                // Clean up
                if (gameState.dragLine) {
                    app.stage.removeChild(gameState.dragLine);
                    gameState.dragLine.destroy();
                    gameState.dragLine = null;
                }
                gameState.selectedCell = null;
                gameState.isDragging = false;
            }
        }

        // Touch event handlers
        function onTouchStart(event) {
            event.preventDefault(); // Prevent scrolling and zooming
            if (gameState.gameOver || !gameState.isPlaying) return; // Don't allow input when game is over or not playing
            
            const touch = event.touches[0];
            const coords = screenToGameCoords(touch.clientX, touch.clientY);
            
            const cell = getCellFromPosition(coords.x, coords.y);
            if (cell && cell.owner === 'player' && cell.units.length > 0) {
                gameState.selectedCell = cell;
                gameState.isDragging = true;
                
                // Create drag line
                gameState.dragLine = new PIXI.Graphics();
                app.stage.addChild(gameState.dragLine);
            }
        }

        function onTouchMove(event) {
            event.preventDefault(); // Prevent scrolling
            if (gameState.isDragging && gameState.selectedCell) {
                const touch = event.touches[0];
                const coords = screenToGameCoords(touch.clientX, touch.clientY);
                
                // Draw line from selected cell to touch point
                const start = gameState.selectedCell.getCenterWorld();
                gameState.dragLine.clear();
                gameState.dragLine.lineStyle(3, 0xFFFFFF, 0.5);
                gameState.dragLine.moveTo(start.x, start.y);
                gameState.dragLine.lineTo(coords.x, coords.y);
            }
        }

        function onTouchEnd(event) {
            event.preventDefault(); // Prevent any default behavior
            if (gameState.isDragging && gameState.selectedCell) {
                const touch = event.changedTouches[0] || event.touches[0];
                const coords = screenToGameCoords(touch.clientX, touch.clientY);
                
                const targetCell = getCellFromPosition(coords.x, coords.y);
                if (targetCell && targetCell !== gameState.selectedCell) {
                    // Send units
                    const unitsToSend = gameState.selectedCell.units.filter(u => u.owner === 'player');
                    unitsToSend.forEach(unit => {
                        unit.moveTo(targetCell);
                    });
                }
                
                // Clean up
                if (gameState.dragLine) {
                    app.stage.removeChild(gameState.dragLine);
                    gameState.dragLine.destroy();
                    gameState.dragLine = null;
                }
                gameState.selectedCell = null;
                gameState.isDragging = false;
            }
        }

        // Update UI
        function updateUI() {
            const playerUnits = gameState.units.filter(u => u.owner === 'player').length;
            const enemyUnits = gameState.units.filter(u => u.owner === 'enemy').length;
            
            document.getElementById('playerUnits').textContent = playerUnits;
            document.getElementById('enemyUnits').textContent = enemyUnits;
            
            // Update score (tiles owned)
            const blueTiles = countOwnedCells('player');
            const redTiles = countOwnedCells('enemy');
            document.getElementById('blueTiles').textContent = blueTiles;
            document.getElementById('redTiles').textContent = redTiles;
        }

        // Simple AI for enemy
        function updateAI(dt) {
            if (gameState.gameOver || !gameState.isPlaying) return; // Don't update AI if game is over or not playing
            
            // Initialize delay on first call
            if (gameState.aiNextMoveDelay === 0) {
                // Random delay between 2-4 seconds
                gameState.aiNextMoveDelay = (2 + Math.random() * 2) / GAME_SPEED;
            }
            
            // Check if it's time to make a move
            gameState.aiMoveTimer += dt;
            if (gameState.aiMoveTimer >= gameState.aiNextMoveDelay) {
                gameState.aiMoveTimer = 0;
                
                const enemyCells = [];
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        const cell = gameState.cells[row][col];
                        if (cell.owner === 'enemy' && cell.units.length > 0) {
                            enemyCells.push(cell);
                        }
                    }
                }
                
                if (enemyCells.length > 0) {
                    const fromCell = enemyCells[Math.floor(Math.random() * enemyCells.length)];
                    const adjacentCells = [];
                    
                    // Get adjacent cells
                    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    directions.forEach(([dr, dc]) => {
                        const newRow = fromCell.row + dr;
                        const newCol = fromCell.col + dc;
                        if (newRow >= 0 && newRow < GRID_SIZE && newCol >= 0 && newCol < GRID_SIZE) {
                            adjacentCells.push(gameState.cells[newRow][newCol]);
                        }
                    });
                    
                    if (adjacentCells.length > 0) {
                        const toCell = adjacentCells[Math.floor(Math.random() * adjacentCells.length)];
                        const unitsToSend = fromCell.units.filter(u => u.owner === 'enemy');
                        unitsToSend.forEach(unit => {
                            unit.moveTo(toCell);
                        });
                    }
                }
                
                // Set next random delay between 2-4 seconds
                gameState.aiNextMoveDelay = (2 + Math.random() * 2) / GAME_SPEED;
            }
        }

        // Count owned cells
        function countOwnedCells(owner) {
            let count = 0;
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    if (gameState.cells[row][col].owner === owner) {
                        count++;
                    }
                }
            }
            return count;
        }

        // Spawn units
        function spawnUnits(dt) {
            if (gameState.gameOver || !gameState.isPlaying) return; // Don't spawn if game is over or not playing
            
            // Player spawning in bottom right (4, 4)
            gameState.playerSpawnTimer += dt;
            const playerCells = countOwnedCells('player');
            const playerSpawnRate = Math.max(0.5 / GAME_SPEED, BASE_SPAWN_RATE - (playerCells * SPAWN_RATE_PER_CELL));
            
            if (gameState.playerSpawnTimer >= playerSpawnRate) {
                gameState.playerSpawnTimer = 0;
                const spawnCell = gameState.cells[4][4];
                if (spawnCell.owner === 'player') {
                    const unit = new Unit('player', spawnCell);
                    gameState.units.push(unit);
                    gameState.playerTotalUnitsProduced++;
                }
            }
            
            // Enemy spawning in top left (0, 0)
            gameState.enemySpawnTimer += dt;
            const enemyCells = countOwnedCells('enemy');
            const enemySpawnRate = Math.max(0.5 / GAME_SPEED, BASE_SPAWN_RATE - (enemyCells * SPAWN_RATE_PER_CELL));
            
            if (gameState.enemySpawnTimer >= enemySpawnRate) {
                gameState.enemySpawnTimer = 0;
                const spawnCell = gameState.cells[0][0];
                if (spawnCell.owner === 'enemy') {
                    const unit = new Unit('enemy', spawnCell);
                    gameState.units.push(unit);
                    gameState.enemyTotalUnitsProduced++;
                }
            }
        }

        // Check for win/lose conditions
        function checkGameOver() {
            if (gameState.gameOver || !gameState.isPlaying) return; // Already game over or not playing
            
            const totalCells = GRID_SIZE * GRID_SIZE;
            const playerCells = countOwnedCells('player');
            const enemyCells = countOwnedCells('enemy');
            
            if (playerCells === totalCells) {
                gameState.gameOver = true;
                gameState.isPlaying = false;
                
                // If player won on Hard difficulty, unlock God mode
                if (DIFFICULTY_LEVEL === 2) {
                    localStorage.setItem('hardBeaten', 'true');
                    updateDifficultySelector();
                }
                
                updateDifficultyButtonsState();
                
                setTimeout(() => {
                    alert('You win!');
                }, 100);
            } else if (enemyCells === totalCells) {
                gameState.gameOver = true;
                gameState.isPlaying = false;
                updateDifficultyButtonsState();
                setTimeout(() => {
                    alert('You lose!');
                }, 100);
            }
        }

        // Restart the game
        function restartGame() {
            // Clean up all units
            gameState.units.forEach(unit => {
                unit.destroy();
            });
            
            // Clean up all cells
            gameState.cells.forEach(row => {
                row.forEach(cell => {
                    app.stage.removeChild(cell.container);
                    cell.container.destroy({ children: true });
                });
            });
            
            // Clean up drag line if it exists
            if (gameState.dragLine) {
                app.stage.removeChild(gameState.dragLine);
                gameState.dragLine.destroy();
                gameState.dragLine = null;
            }
            
            // Reset game state
            gameState.cells = [];
            gameState.units = [];
            gameState.selectedCell = null;
            gameState.isDragging = false;
            gameState.playerSpawnTimer = 0;
            gameState.enemySpawnTimer = 0;
            gameState.aiMoveTimer = 0;
            gameState.aiNextMoveDelay = 0;
            gameState.playerTotalUnitsProduced = 0;
            gameState.enemyTotalUnitsProduced = 0;
            gameState.gameOver = false;
            gameState.isPlaying = true;
            
            // Reinitialize
            initGrid();
            initUnits();
            updateUI();
            updateDifficultyButtonsState(); // Disable buttons when game starts
        }

        // Start a new game
        function startNewGame() {
            restartGame();
        }

        // Game loop
        app.ticker.add((ticker) => {
            if (!gameState.isPlaying) return; // Don't update game if not playing
            
            // Get delta time in seconds (PixiJS ticker.elapsedMS is in milliseconds)
            // Clamp delta time to prevent huge jumps on first frame or lag spikes
            const rawDt = (ticker.elapsedMS || 16.67) / 1000; // Default to ~60fps if undefined
            const dt = Math.min(rawDt, 0.1); // Cap at 100ms (10fps minimum) to prevent issues
            
            // Update all units
            gameState.units.forEach(unit => {
                unit.update(ticker.elapsedMS || 16.67);
            });
            
            // Handle unit conflicts and capture progress
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const cell = gameState.cells[row][col];
                    const playerUnits = cell.units.filter(u => u.owner === 'player');
                    const enemyUnits = cell.units.filter(u => u.owner === 'enemy');
                    
                    // Combat: units destroy each other
                    if (playerUnits.length > 0 && enemyUnits.length > 0) {
                        const minCount = Math.min(playerUnits.length, enemyUnits.length);
                        
                        for (let i = 0; i < minCount; i++) {
                            // Remove units
                            const pUnit = playerUnits[i];
                            const eUnit = enemyUnits[i];
                            
                            pUnit.destroy();
                            eUnit.destroy();
                            
                            gameState.units = gameState.units.filter(u => u !== pUnit && u !== eUnit);
                            cell.units = cell.units.filter(u => u !== pUnit && u !== eUnit);
                        }
                    }
                    
                    // Update capture progress and unit count
                    cell.updateCaptureProgress(dt);
                    cell.updateUnitCount();
                }
            }
            
            // Spawn units based on owned cells
            spawnUnits(dt);
            
            updateAI(dt);
            updateUI();
            
            // Check for win/lose conditions
            checkGameOver();
        });

        // Update selected button state
        function updateSelectedButton() {
            const buttons = document.querySelectorAll('.difficultyButton');
            buttons.forEach(button => {
                const level = parseInt(button.getAttribute('data-level'));
                if (level === DIFFICULTY_LEVEL) {
                    button.classList.add('selected');
                } else {
                    button.classList.remove('selected');
                }
            });
        }

        // Update difficulty buttons enabled/disabled state based on game state
        function updateDifficultyButtonsState() {
            const buttons = document.querySelectorAll('.difficultyButton');
            buttons.forEach(button => {
                // Disable if game is playing, but preserve the unlock state for God button
                if (gameState.isPlaying) {
                    button.disabled = true;
                } else {
                    // Re-enable, but check unlock status for God button
                    const level = parseInt(button.getAttribute('data-level'));
                    if (level === 3) {
                        const hardBeaten = localStorage.getItem('hardBeaten') === 'true';
                        button.disabled = !hardBeaten;
                    } else {
                        button.disabled = false;
                    }
                }
            });
        }

        // Update difficulty selector based on unlock status
        function updateDifficultySelector() {
            const hardBeaten = localStorage.getItem('hardBeaten') === 'true';
            
            // If God is currently selected but not unlocked, switch to Normal
            if (!hardBeaten && DIFFICULTY_LEVEL === 3) {
                DIFFICULTY_LEVEL = 1;
                updateSelectedButton();
            }
            
            // Update button states (handles both unlock status and game playing state)
            updateDifficultyButtonsState();
        }

        // Setup difficulty buttons
        const difficultyButtons = document.querySelectorAll('.difficultyButton');
        difficultyButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                if (button.disabled || gameState.isPlaying) return;
                DIFFICULTY_LEVEL = parseInt(button.getAttribute('data-level'));
                updateSelectedButton();
            });
        });

        // Setup New Game button
        document.getElementById('newGameButton').addEventListener('click', startNewGame);

        // Initialize difficulty selector on page load
        updateSelectedButton();
        updateDifficultySelector();

        // Initialize game (but don't start playing)
        initGrid();
        setupInput();
        updateUI();
    </script>
</body>
</html>